{"ts":1366209499436,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1366209511280,"patch":[[{"diffs":[[1,"# Commonly used email steps\r\n#\r\n# To add your own steps make a custom_email_steps.rb\r\n# The provided methods are:\r\n#\r\n# last_email_address\r\n# reset_mailer\r\n# open_last_email\r\n# visit_in_email\r\n# unread_emails_for\r\n# mailbox_for\r\n# current_email\r\n# open_email\r\n# read_emails_for\r\n# find_email\r\n#\r\n# General form for email scenarios are:\r\n#   - clear the email queue (done automatically by email_spec)\r\n#   - execute steps that sends an email\r\n#   - check the user received an/no/[0-9] emails\r\n#   - open the email\r\n#   - inspect the email contents\r\n#   - interact with the email (e.g. click links)\r\n#\r\n# The Cucumber steps below are setup in this order.\r\n\r\nmodule EmailHelpers\r\n  def current_email_address\r\n    # Replace with your a way to find your current email. e.g @current_user.email\r\n    # last_email_address will return the last email address used by email spec to find an email.\r\n    # Note that last_email_address will be reset after each Scenario.\r\n    last_email_address || \"example@example.com\"\r\n  end\r\nend\r\n\r\nWorld(EmailHelpers)\r\n\r\n#\r\n# Reset the e-mail queue within a scenario.\r\n# This is done automatically before each scenario.\r\n#\r\n\r\nGiven /^(?:a clear email queue|no emails have been sent)$/ do\r\n  reset_mailer\r\nend\r\n\r\n#\r\n# Check how many emails have been sent/received\r\n#\r\n\r\nThen /^(?:I|they|\"([^\"]*?)\") should receive (an|no|\\d+) emails?$/ do |address, amount|\r\n  unread_emails_for(address).size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^(?:I|they|\"([^\"]*?)\") should have (an|no|\\d+) emails?$/ do |address, amount|\r\n  mailbox_for(address).size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^(?:I|they|\"([^\"]*?)\") should receive (an|no|\\d+) emails? with subject \"([^\"]*?)\"$/ do |address, amount, subject|\r\n  unread_emails_for(address).select { |m| m.subject =~ Regexp.new(Regexp.escape(subject)) }.size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^(?:I|they|\"([^\"]*?)\") should receive (an|no|\\d+) emails? with subject \\/([^\"]*?)\\/$/ do |address, amount, subject|\r\n  unread_emails_for(address).select { |m| m.subject =~ Regexp.new(subject) }.size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^(?:I|they|\"([^\"]*?)\") should receive an email with the following body:$/ do |address, expected_body|\r\n  open_email(address, :with_text => expected_body)\r\nend\r\n\r\n#\r\n# Accessing emails\r\n#\r\n\r\n# Opens the most recently received email\r\nWhen /^(?:I|they|\"([^\"]*?)\") opens? the email$/ do |address|\r\n  open_email(address)\r\nend\r\n\r\nWhen /^(?:I|they|\"([^\"]*?)\") opens? the email with subject \"([^\"]*?)\"$/ do |address, subject|\r\n  open_email(address, :with_subject => subject)\r\nend\r\n\r\nWhen /^(?:I|they|\"([^\"]*?)\") opens? the email with subject \\/([^\"]*?)\\/$/ do |address, subject|\r\n  open_email(address, :with_subject => Regexp.new(subject))\r\nend\r\n\r\nWhen /^(?:I|they|\"([^\"]*?)\") opens? the email with text \"([^\"]*?)\"$/ do |address, text|\r\n  open_email(address, :with_text => text)\r\nend\r\n\r\nWhen /^(?:I|they|\"([^\"]*?)\") opens? the email with text \\/([^\"]*?)\\/$/ do |address, text|\r\n  open_email(address, :with_text => Regexp.new(text))\r\nend\r\n\r\n#\r\n# Inspect the Email Contents\r\n#\r\n\r\nThen /^(?:I|they) should see \"([^\"]*?)\" in the email subject$/ do |text|\r\n  current_email.should have_subject(text)\r\nend\r\n\r\nThen /^(?:I|they) should see \\/([^\"]*?)\\/ in the email subject$/ do |text|\r\n  current_email.should have_subject(Regexp.new(text))\r\nend\r\n\r\nThen /^(?:I|they) should see \"([^\"]*?)\" in the email body$/ do |text|\r\n  current_email.default_part_body.to_s.should include(text)\r\nend\r\n\r\nThen /^(?:I|they) should see \\/([^\"]*?)\\/ in the email body$/ do |text|\r\n  current_email.default_part_body.to_s.should =~ Regexp.new(text)\r\nend\r\n\r\nThen /^(?:I|they) should see the email delivered from \"([^\"]*?)\"$/ do |text|\r\n  current_email.should be_delivered_from(text)\r\nend\r\n\r\nThen /^(?:I|they) should see \"([^\\\"]*)\" in the email \"([^\"]*?)\" header$/ do |text, name|\r\n  current_email.should have_header(name, text)\r\nend\r\n\r\nThen /^(?:I|they) should see \\/([^\\\"]*)\\/ in the email \"([^\"]*?)\" header$/ do |text, name|\r\n  current_email.should have_header(name, Regexp.new(text))\r\nend\r\n\r\nThen /^I should see it is a multi\\-part email$/ do\r\n    current_email.should be_multipart\r\nend\r\n\r\nThen /^(?:I|they) should see \"([^\"]*?)\" in the email html part body$/ do |text|\r\n    current_email.html_part.body.to_s.should include(text)\r\nend\r\n\r\nThen /^(?:I|they) should see \"([^\"]*?)\" in the email text part body$/ do |text|\r\n    current_email.text_part.body.to_s.should include(text)\r\nend\r\n\r\n#\r\n# Inspect the Email Attachments\r\n#\r\n\r\nThen /^(?:I|they) should see (an|no|\\d+) attachments? with the email$/ do |amount|\r\n  current_email_attachments.size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^there should be (an|no|\\d+) attachments? named \"([^\"]*?)\"$/ do |amount, filename|\r\n  current_email_attachments.select { |a| a.filename == filename }.size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^attachment (\\d+) should be named \"([^\"]*?)\"$/ do |index, filename|\r\n  current_email_attachments[(index.to_i - 1)].filename.should == filename\r\nend\r\n\r\nThen /^there should be (an|no|\\d+) attachments? of type \"([^\"]*?)\"$/ do |amount, content_type|\r\n  current_email_attachments.select { |a| a.content_type.include?(content_type) }.size.should == parse_email_count(amount)\r\nend\r\n\r\nThen /^attachment (\\d+) should be of type \"([^\"]*?)\"$/ do |index, content_type|\r\n  current_email_attachments[(index.to_i - 1)].content_type.should include(content_type)\r\nend\r\n\r\nThen /^all attachments should not be blank$/ do\r\n  current_email_attachments.each do |attachment|\r\n    attachment.read.size.should_not == 0\r\n  end\r\nend\r\n\r\nThen /^show me a list of email attachments$/ do\r\n  EmailSpec::EmailViewer::save_and_open_email_attachments_list(current_email)\r\nend\r\n\r\n#\r\n# Interact with Email Contents\r\n#\r\n\r\nWhen /^(?:I|they) follow \"([^\"]*?)\" in the email$/ do |link|\r\n  visit_in_email(link)\r\nend\r\n\r\nWhen /^(?:I|they) click the first link in the email$/ do\r\n  click_first_link_in_email\r\nend\r\n\r\n#\r\n# Debugging\r\n# These only work with Rails and OSx ATM since EmailViewer uses RAILS_ROOT and OSx's 'open' command.\r\n# Patches accepted. ;)\r\n#\r\n\r\nThen /^save and open current email$/ do\r\n  EmailSpec::EmailViewer::save_and_open_email(current_email)\r\nend\r\n\r\nThen /^save and open all text emails$/ do\r\n  EmailSpec::EmailViewer::save_and_open_all_text_emails\r\nend\r\n\r\nThen /^save and open all html emails$/ do\r\n  EmailSpec::EmailViewer::save_and_open_all_html_emails\r\nend\r\n\r\nThen /^save and open all raw emails$/ do\r\n  EmailSpec::EmailViewer::save_and_open_all_raw_emails\r\nend"]],"start1":0,"start2":0,"length1":0,"length2":6537}]],"length":6537,"saved":false}
